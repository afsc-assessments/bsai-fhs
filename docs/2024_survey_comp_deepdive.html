<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Maia Kapur maia.kapur@noaa.gov">

<title>Survey Comps Deep Dive</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="2024_survey_comp_deepdive_files/libs/clipboard/clipboard.min.js"></script>
<script src="2024_survey_comp_deepdive_files/libs/quarto-html/quarto.js"></script>
<script src="2024_survey_comp_deepdive_files/libs/quarto-html/popper.min.js"></script>
<script src="2024_survey_comp_deepdive_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2024_survey_comp_deepdive_files/libs/quarto-html/anchor.min.js"></script>
<link href="2024_survey_comp_deepdive_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2024_survey_comp_deepdive_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2024_survey_comp_deepdive_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2024_survey_comp_deepdive_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2024_survey_comp_deepdive_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#close-up-data-comparisons" id="toc-close-up-data-comparisons" class="nav-link" data-scroll-target="#close-up-data-comparisons">Close-up Data Comparisons</a>
  <ul class="collapse">
  <li><a href="#marginal-lengths" id="toc-marginal-lengths" class="nav-link" data-scroll-target="#marginal-lengths">Marginal Lengths</a></li>
  <li><a href="#marginal-ages" id="toc-marginal-ages" class="nav-link" data-scroll-target="#marginal-ages">Marginal Ages</a></li>
  <li><a href="#caals" id="toc-caals" class="nav-link" data-scroll-target="#caals">CAALs</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Survey Comps Deep Dive</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Maia Kapur maia.kapur@noaa.gov </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="background" class="level1">
<h1>Background</h1>
<p>I’ve had a lot of trouble reproducing the survey compositional data used in Model 18.c (2020), which was generated using a combination of data extractions from the deprecated <code>haehnr</code> schema and some bespoke filtration/workup code. For the assessment we use conditional ages-at-length (by sex), marginal lengths (by sex), and marginal ages (by sex, which are ghosted).</p>
<p>The disappearance of the <code>haehnr</code> schema means that I am forced to start with either the <code>bts_specimen_data.csv</code> drawn from <code>afscdata()</code> or the size composition dataframe from <code>gapindex</code>. I am unable to pass either dataset to the legacy (2020) code, since it’s looking for individual columns for <code>MALES</code> and <code>FEMALES</code> (which have been superceded by a <code>SEX</code> column in both cases). Following an intuitive grouping/expansion pipeline (e.g., re-writing my own code to calculate the marginal comp data) resulted in drastically different datasets and modeling outcomes. I was able to calculate CAAL data near enough to the old dataset by starting with the raw <code>specimen</code> data (not <code>gapindex</code>) and passing it through Carey’s code. This is less-than desireable, because I’d prefer to have a single starting source (one package or the other) and updated munging routines for all survey compositional data.</p>
<p>So, the purpose of this document is to dig into where the discrepancy between data sources and workup is arising, and to see whether we can find a best way forward for reproducibly generating these data. <strong>For simplicity we are going to focus on data in year 2010.</strong></p>
</section>
<section id="close-up-data-comparisons" class="level1">
<h1>Close-up Data Comparisons</h1>
<section id="marginal-lengths" class="level2">
<h2 class="anchored" data-anchor-id="marginal-lengths">Marginal Lengths</h2>
<p>As stated above, the 2020 model pulled from the <code>haehnr</code> schema, which I can no longer do, while I do have the raw file (<code>'2020/data/lengths_survey_ebs.csv'</code>). Let’s compare that with <code>2024/raw/bsai_ts_length_data.csv</code>, from <code>afscdata</code>, and the contents of <code>production_sizecomp_stratum</code> following the <code>gapindex</code> vignette hosted <a href="https://github.com/afsc-gap-products/gapindex/blob/main/vignettes/ex_agecomps_ebs_standard.Rmd">here</a>.</p>
<p>Comparing the <code>names</code> of these objects, there are a few key differences: - the <code>haehnr</code> table has a column for males and females separately; GAP told us this should be replaced by filtering <code>POPULATIONCOUNT</code> on the <code>SEX</code> column of their table. There doesn’t seem to be an equivalent column for the <code>afscdata</code> table.</p>
<ul>
<li>The counts suggest that <code>haehnr</code> table has pre-filled zeros (hence roughly double the number of records as <code>gapindex</code>, and an identical number of records between sexes). For example, for length bin 80 the <code>haehnr</code> schema has automatically populated itself with an empty row for males of length 80.</li>
<li>What comes out of <code>afscata</code> is subjectively less similar to <code>haehnr</code> than <code>gapindex</code>. (Always important to recall that in these datasets, males are coded as sex = 1). The scale is different between approaches.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 3
# Groups:   source [3]
  source                    sex     `n()`
  &lt;chr&gt;                     &lt;chr&gt;   &lt;int&gt;
1 afscdata$frequency        females   285
2 afscdata$frequency        males     252
3 gapindex$population_count females   282
4 gapindex$population_count males     240
5 haehnr$MALES/$FEMALES     females   293
6 haehnr$MALES/$FEMALES     males     293</code></pre>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">Strong distinctions between all three data pull methods; afscdata seems to have far more small individuals.</figcaption>
</figure>
</div>
</div>
</div>
<p>Now I will calculate the frequencies of each length bin and compare outcomes, across data sources as well as compared to the inputs in the 2020 model. Recall that these are still the raw data; they haven’t been binned. This gives me reason to a) abandon the <code>afscdata</code> pull from the outset, and b) dig into what’s happening to cause the subsequent workup on these data to diverge so much from before.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 82 × 55
    YEAR SEX       `350`     `400`  `320`   `150`   `140`  `240`  `190`   `130`
   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
 1  1982 females 0.0249  0.00835   0.0556 0.0209  0.0236  0.0486 0.0296 0.0217 
 2  1982 males   0.00492 0.000222  0.0352 0.0253  0.0284  0.0481 0.0304 0.0239 
 3  1983 females 0.0427  0.00535   0.0577 0.0174  0.0182  0.0333 0.0386 0.0270 
 4  1983 males   0.0121  0.0000508 0.0486 0.0155  0.0238  0.0395 0.0445 0.0345 
 5  1984 males   0.0124  0.000128  0.0460 0.0368  0.0298  0.0425 0.0405 0.0171 
 6  1984 females 0.0335  0.00580   0.0398 0.0439  0.0235  0.0443 0.0319 0.0226 
 7  1985 males   0.0246  0.000560  0.0499 0.0144  0.0152  0.0407 0.0458 0.00776
 8  1985 females 0.0354  0.0113    0.0446 0.0169  0.0145  0.0408 0.0459 0.00876
 9  1986 females 0.0450  0.0195    0.0482 0.00892 0.00806 0.0519 0.0175 0.00687
10  1986 males   0.0266  0.000757  0.0681 0.00897 0.0130  0.0598 0.0316 0.0190 
# ℹ 72 more rows
# ℹ 45 more variables: `280` &lt;dbl&gt;, `160` &lt;dbl&gt;, `230` &lt;dbl&gt;, `120` &lt;dbl&gt;,
#   `270` &lt;dbl&gt;, `180` &lt;dbl&gt;, `290` &lt;dbl&gt;, `260` &lt;dbl&gt;, `300` &lt;dbl&gt;,
#   `100` &lt;dbl&gt;, `330` &lt;dbl&gt;, `380` &lt;dbl&gt;, `210` &lt;dbl&gt;, `220` &lt;dbl&gt;,
#   `340` &lt;dbl&gt;, `110` &lt;dbl&gt;, `200` &lt;dbl&gt;, `170` &lt;dbl&gt;, `250` &lt;dbl&gt;,
#   `310` &lt;dbl&gt;, `420` &lt;dbl&gt;, `360` &lt;dbl&gt;, `370` &lt;dbl&gt;, `440` &lt;dbl&gt;,
#   `390` &lt;dbl&gt;, `80` &lt;dbl&gt;, `450` &lt;dbl&gt;, `430` &lt;dbl&gt;, `410` &lt;dbl&gt;, …</code></pre>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">The gapindex and haehnr compositional curves are nearly indistinguishable, but they still don’t match the 2020 data (not shown).</figcaption>
</figure>
</div>
</div>
</div>
<p>Looking at an individual value, they match to the third decimal with the 2020 model.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 7
   year length sex        value source                           tot   freq
  &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt;
1  2006    280 females 69433469 haehnr$MALES/$FEMALES     1957115441 0.0355
2  2006    280 females      520 afscdata$frequency             12132 0.0429
3  2006    280 females 34500199 gapindex$population_count  974874633 0.0354</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>      Obs
1 0.01691</code></pre>
</div>
</div>
<p>This is good news; it means we can safely use the <code>gapindex</code> products. I went through and did some data wrangling, and after debugging some unwieldy <code>dplyr::group_by()</code> terms was able to reproduce the marginal length compositions from the 2020 assessment. Other mistakes involved wrong binning behavior for the plus and minus groups.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Comparison of marginal length comps, early years</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">Comparison of marginal length comps, later years</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">All of the lines are overlapping.</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">All of the lines are overlapping.</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
<p><strong>I am confident I can use the</strong> <code>gapindex</code> <code>production_sizecomp_stratum</code> <strong>object to get to a faithful reproduction of the 2020 marginal length comps</strong>.</p>
</section>
<section id="marginal-ages" class="level2">
<h2 class="anchored" data-anchor-id="marginal-ages">Marginal Ages</h2>
<p>Let’s do the same workup starting with the <code>gapindex</code> <code>production_agecomp_stratum</code>. If these faithfully match we can more confidently move forward with the CAAL calculation (though remember the marginal ages are ghosted).</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true" href="">Comparison of marginal age comps, early years</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false" href="">Comparison of marginal age comps, later years</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">All of the lines are overlapping.</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption class="figure-caption">All of the lines are overlapping.</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
<p><strong>I am confident I can use the</strong> <code>gapindex</code> <code>production_agecomp</code> <strong>object to get to a faithful reproduction of the 2020 marginal age comps (these are not fit to in the model).</strong></p>
</section>
<section id="caals" class="level2">
<h2 class="anchored" data-anchor-id="caals">CAALs</h2>
<p>I was original able to get something that looked like the previous inputs by starting with the specimen CSV from <code>afscdata</code> and passing it through Carey’s code. I’d rather do this using the <code>gapindex</code> data and a clean, single pipe workflow.</p>
<p>Note that this ignores the values in <code>POPULATION_COUNT</code> and also is not calculating an actual frequency (e.g., inputs are &gt; 1). We simply ensure the data are classified into the right bins, then summarise the number of fish in each bin.</p>
<p>Also note that the <code>GAP_PRODUCTS.AGECOMP</code> table for the EBS currently only contains stratum- and region-level age composition values calculated using a global ALK conditioned on age data from the EBS Standard + NW area. The vignette on <code>gapindex</code> is a workaround if you wanted to get age composition values using a global ALK conditioned on age data from just the EBS Standard area.</p>
<p><strong>The bubbles on these plots now overlap completely; I’m confident I can re-create the CAALs using a much tighter pipeline than before.</strong></p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true" href="">Comparison of CAALs, early years</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-2" role="tab" aria-controls="tabset-3-2" aria-selected="false" href="">Comparison of CAALs, later years</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<div class="cell">
<div class="cell-output-display">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
<div id="tabset-3-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-2-tab">
<div class="cell">
<div class="cell-output-display">
<p><img src="2024_survey_comp_deepdive_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>